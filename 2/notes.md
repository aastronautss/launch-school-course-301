# Notes: Course 301, Lesson 2

## Lecture 3

### Rails Forms

#### 'controller_name#create'

This is a `POST` request to `/controller_name` (plural). Parameters are stored in the params hash and we can pass those to the `ActiveRecordModel::create` method (or `#new` -> `#save`) to store it into the database.

#### Authenticity Tokens

In `ApplicationController` we have a call to `protect_from_forgery`, which tries to prevent against forms submitting data to the application. This embeds a token into your form when it is generated.

#### Form helper tags!

We kick off our form using `form_tag`, and passing it a path and a block. In the block we use tag helpers for our various attributes and submit buttons.

```erb
<%= form_tag '/posts' do %> # Observe the `=` sign, since we need it to put
                            # the tag into the document itself.

  <%= label_tag :title %>   # We pass the symbol corresponding to the name
                            # of the attribute
  <%= text_field_tag :title %>

  <br />                    # We can also put pure HTML into this block,
                            # as usual.

  <%= submit_tag 'Create Post', class: 'btn btn-primary' %>
                            # We can pass a string into the block to get the
                            # tag to display something else. A `class` key
                            # allows us to set a `class=` attribute in the
                            # final HTML. This works for most helpers.
<% end %>
```

#### Model-backed forms

We use `form_for` for additional model-backed methods. We pass the model itself into the form along with a block, and the method passes an `f` object into the block so we can use those methods.

```erb
<%= form_for @post do |f| %>
  <%= f.label :title %>
  <%= f.text_field :title %>
  <br />
  <%= f.submit 'Create Post', class: 'btn btn-primary' %>
<% end %>
```

From the model, (in this case `@post`), the method determines where to submit the form to. (REMEMBER TO SET IT UP IN THE CONTROLLER--for the `new` action this means creating an empty model with `Model#new`).

Here, the submitted form gives us a nested hash in `params` (in this case, it's stored in `params[:post]`). This allows us to simply pass that value into `Model#create` as mass assignment. It does this by proving a `name` HTML attribute to each input tag that it can use to easily pick this out (e.g. `post[title]`).

For this reason, we want to use `form_for` whenever possible.

Limitations: the symbols we pass into `f`'s methods need to correspond to actual attributes (columns in the database).

#### Strong parameters!

In the old days, we'd add `attr_accessible` to the model layer in order to whitelist incoming params. This caused a lot of security problems, so the concern was moved to the controller layer with actions.

We create a `model_params` method and use this for validation.

```ruby
def post_params
  params.require(:post)
end
```

This requires us to have our attributes stored in a `:post` top level key. Then we permit the relevant attributes (including virutal attributes):

```ruby
def post_params
  params.require(:post).permit :title, :url, :creator
end
```

If we want to whitelist everything, we can use `permit!` to permit everything:

```ruby
def post_params
  params.require(:post).permit!
end
```

This allows us to wrap it up in code like the following:

```ruby
def post_params
  if user.admin?
    params.require(:post).permit!
  else
    params.require(:post).permit :title, :url
  end
end
```

This returns a filtered hash with all permitted attributes. Hashes with unsupported params silently fail (this is the source of a lot of silent bugs, but it's for the best, security-wise).

#### The pattern re: `create` action with a model-backed form

```ruby
def create
  @post = Post.new post_params      # Store new post in an instance variable,
                                    # in memory.

  if @post.save                     # Check if it saves
    flash[:notice] = 'Your post was created.'
    redirect_to posts_path          # If successful, redirect.
  else
    render 'new'                    # Else, render the action that we came from
  end
end
```

### Validating the `new` form

We add validations to our model layer:

```ruby
class Post < ActiveRecord::Base
  validates :title, presence: true
end
```

If we try to create a new post and hit the database with invalid attributes, the method we call returns false:

```ruby
p = Post.create url: 'google.com'
#=> false
```

Our variable still points to an `ActiveRecord` model, but only stored in memory. We can see the errors generated by the previous call from `#errors`, which returns an hash-like structure:

```ruby
p.errors
#=> #<ActiveModel::Errors:0x00561feddcf240 @base=#<Post id: nil, url: "google.com", title: nil, description: "hello", created_at: nil, updated_at: nil, user_id: nil>, @messages={:title=>["can't be blank"]}>
```

The hash is under `@messages`. We can also use `ActiveModel::Errors#full_messages` to get an array-like structure:

```ruby
p.errors.full_messages
#=> ["Title can't be blank"]
```

If there are more errors, then there are more in the

Why do the errors exist on the `ActiveRecord` model? So if we use `render`, we get access to the instance variables and we can display the errors.

```erb
<% if @post.errors.any? %>
  <div class='alert alert-error'>
    <h5>There were some errors:</h5>
    <ul>
      <% @post.errors.full_messages.each do |msg| %>
        <li><%= msg %></li>
      <% end %>
    </ul>
  </div>
<% end %>
```

Rails also wraps `div`s around each fields that have an error attached to them, with the class `field_with_errors`.

This is why we must render in the case of a validation error.

### Other stuff about `form_for`:

`form_for` does a lot of guessing. If we're passing a new object, then it guesses that the method is `POST` and the action is `/posts`. If we pass an existing object, it pre-populates the values and goes to `/posts/:id` (`id` prepopulated), but the method is still `POST`.

Why is this, even if we don't have any `POST` verbs going to `/posts/:id`? HTML forms can typically only send `POST` and `GET` requests, so Rails puts an `_method` hidden input with the `value` as `patch`. Rails uses this input instead of the method denoted by the form.

This means that the `new` post form and the `edit` post form can be identical, so we can abstract that away with a partial. We just need to make sure we have an instance variable with the same name as `form_for` needs.

### `before_action`

This is a way of running some code before an action:

```ruby
class PostsController < ApplicationController
  before_action :set_post
  # ...
  private
  # ...
  def set_post
    @post = Post.find params[:id]
  end
end
```

`set_post` will be called before each action in the controller. If we want to limit this to a few actions, we can use `:only`:

```ruby
# ...
  before_action :set_post, only: [:show, :edit, :update]
# ...
```

We use this for a few different reasons:

- Setting up instance variables
- Redirecting based on some condition
  - The action no longer executes if we redirect in a `before_action`.
  - This is good for checking logins.

### Nested routes, continued

What we've covered is a pretty generic set of actions for CRUD actions, and it's a RESTful interface.

Once you know this, you need to start handling the special cases, which don't flow quite as well, for example, comments. Comments don't have a 'show comments' page. They exist, rather, on the Post page.

The form for this looks like this:

```erb
<%= form_for [@post, @comment] do |f| %>
  ...
<% end %>
```

`@post` needs to be an existing post, while `@comment` needs to be a new comment. This makes `form_for` infer that it's posting to `/posts/:id/comments`.

When this form is submitted, everything is nested in `params` under the `comment` key.

## Lecture 4

### Nested routes

Several tricks to get this to work:

#### `form_for`

We need to pass an array into `form_for`, with the first argument being (in this case) the `Post` that we want to add the comment to, and the second being the `Comment` we're working with (remember, it can be a new one or one that is linked to a row in the table).

```erb
<%= form_for [@post, @comment] do |f| %>
  <%= f.test_area :body %>
<% end %>
```

This submits to `/posts/:post_id/comments` as a `POST` request.

When it submits to the `CommentsController`, this is a slight deviation from our RESTful action pattern. To add the comment to the post, we use

```ruby
def create
  @post = Post.find params[:post_id]
  @comment = @post.comments.build comment_params

  # ...
end
```

or any variation to add the comment to the post.

#### Why nested routes?

Think about the URLs when you're thinking about the mockups--they're not always going to be at the top level. URLs are part of the interface.

### Helpers

Currently, our links don't actually go to the correct places! We could go into the database, but we want to keep the data as it's

Whenever we see logic in a template, we want to abstract it out. If it's a presentation-level concern, we use helpers for this (rather than adding methods to the model).

Helpers correlate to the view templates, so we'd put them in their appropriate classes. `ApplicationHelper` is for app-wide helpers.

To use them, we just call the method.

#### Fat models, thin controllers.

We typically want to move extra logic to models, rather than the controller layer. Models best capture business logic. It gets really hard to test controllers--it's much easier to do so with models.

### Other stuff for model-backed forms

When we set something like `<%= f.text_area :description %>`, the key we pass into the method needs to have a corresponding setter method. Either a column or a virtual attribute. Basically, anything we can mass-assign.

### Adding stuff to M:M associations

Say we have `post = Post.first`. We can clear its categories by calling the setter `post.categories=` and passing in a blank array:

```ruby
post.categories = []
post.categories
#=> Some empty AR collection
```

We can also mass assign the association with IDs:

```ruby
post.category_ids
#=> []

post.category_ids = [2, 3]

post.category_ids
#=> [2, 3]
```

So in the form, we can make a `select` box. This is pretty confusing.

#### The form

When submitting an input in which we're expecting multiple values (like a `multiple` select), we need to add `[]` to the `name` attribute:

```html
<select name='options[]' multiple='multiple'></select>
```

We can force these inputs to go into our `post` hash in `params` by doing the following:

```html
<select name='post[category_ids][]'></select>
```

For our validations, the syntax is a little weird when it comes to collections:

```ruby
params.require(:post).permit :title, :url, :description, category_ids: []
```

## Additional Lecure Notes

