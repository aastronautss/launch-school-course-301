# Notes: Course 301, Lesson 2

## Lecture 3

### Rails Forms

#### 'controller_name#create'

This is a `POST` request to `/controller_name` (plural). Parameters are stored in the params hash and we can pass those to the `ActiveRecordModel::create` method (or `#new` -> `#save`) to store it into the database.

#### Authenticity Tokens

In `ApplicationController` we have a call to `protect_from_forgery`, which tries to prevent against forms submitting data to the application. This embeds a token into your form when it is generated.

#### Form helper tags!

We kick off our form using `form_tag`, and passing it a path and a block. In the block we use tag helpers for our various attributes and submit buttons.

```erb
<%= form_tag '/posts' do %> # Observe the `=` sign, since we need it to put
                            # the tag into the document itself.

  <%= label_tag :title %>   # We pass the symbol corresponding to the name
                            # of the attribute
  <%= text_field_tag :title %>

  <br />                    # We can also put pure HTML into this block,
                            # as usual.

  <%= submit_tag 'Create Post', class: 'btn btn-primary' %>
                            # We can pass a string into the block to get the
                            # tag to display something else. A `class` key
                            # allows us to set a `class=` attribute in the
                            # final HTML. This works for most helpers.
<% end %>
```

#### Model-backed forms

We use `form_for` for additional model-backed methods. We pass the model itself into the form along with a block, and the method passes an `f` object into the block so we can use those methods.

```erb
<%= form_for @post do |f| %>
  <%= f.label :title %>
  <%= f.text_field :title %>
  <br />
  <%= f.submit 'Create Post', class: 'btn btn-primary' %>
<% end %>
```

From the model, (in this case `@post`), the method determines where to submit the form to. (REMEMBER TO SET IT UP IN THE CONTROLLER--for the `new` action this means creating an empty model with `Model#new`).

Here, the submitted form gives us a nested hash in `params` (in this case, it's stored in `params[:post]`). This allows us to simply pass that value into `Model#create` as mass assignment. It does this by proving a `name` HTML attribute to each input tag that it can use to easily pick this out (e.g. `post[title]`).

For this reason, we want to use `form_for` whenever possible.

Limitations: the symbols we pass into `f`'s methods need to correspond to actual attributes (columns in the database).

#### Strong parameters!

In the old days, we'd add `attr_accessible` to the model layer in order to whitelist incoming params. This caused a lot of security problems, so the concern was moved to the controller layer with actions.

We create a `model_params` method and use this for validation.

```ruby
def post_params
  params.require(:post)
end
```

This requires us to have our attributes stored in a `:post` top level key. Then we permit the relevant attributes (including virutal attributes):

```ruby
def post_params
  params.require(:post).permit :title, :url, :creator
end
```

If we want to whitelist everything, we can use `permit!` to permit everything:

```ruby
def post_params
  params.require(:post).permit!
end
```

This allows us to wrap it up in code like the following:

```ruby
def post_params
  if user.admin?
    params.require(:post).permit!
  else
    params.require(:post).permit :title, :url
  end
end
```

This returns a filtered hash with all permitted attributes. Hashes with unsupported params silently fail (this is the source of a lot of silent bugs, but it's for the best, security-wise).

#### The pattern re: `create` action with a model-backed form

```ruby
def create
  @post = Post.new post_params      # Store new post in an instance variable,
                                    # in memory.

  if @post.save                     # Check if it saves
    flash[:notice] = 'Your post was created.'
    redirect_to posts_path          # If successful, redirect.
  else
    render 'new'                    # Else, render the action that we came from
  end
end
```

### Validating the `new` form

We add validations to our model layer:

```ruby
class Post < ActiveRecord::Base
  validates :title, presence: true
end
```

If we try to create a new post and hit the database with invalid attributes, the method we call returns false:

```ruby
p = Post.create url: 'google.com'
#=> false
```

Our variable still points to an `ActiveRecord` model, but only stored in memory. We can see the errors generated by the previous call from `#errors`, which returns an hash-like structure:

```ruby
p.errors
#=> #<ActiveModel::Errors:0x00561feddcf240 @base=#<Post id: nil, url: "google.com", title: nil, description: "hello", created_at: nil, updated_at: nil, user_id: nil>, @messages={:title=>["can't be blank"]}>
```

The hash is under `@messages`. We can also use `ActiveModel::Errors#full_messages` to get an array-like structure:

```ruby
p.errors.full_messages
#=> ["Title can't be blank"]
```

If there are more errors, then there are more in the

Why do the errors exist on the `ActiveRecord` model? So if we use `render`, we get access to the instance variables and we can display the errors.

```erb
<% if @post.errors.any? %>
  <div class='alert alert-error'>
    <h5>There were some errors:</h5>
    <ul>
      <% @post.errors.full_messages.each do |msg| %>
        <li><%= msg %></li>
      <% end %>
    </ul>
  </div>
<% end %>
```

Rails also wraps `div`s around each fields that have an error attached to them, with the class `field_with_errors`.

This is why we must render in the case of a validation error.

### Other stuff about `form_for`:

`form_for` does a lot of guessing. If we're passing a new object, then it guesses that the method is `POST` and the action is `/posts`. If we pass an existing object, it pre-populates the values and goes to `/posts/:id` (`id` prepopulated), but the method is still `POST`.

Why is this, even if we don't have any `POST` verbs going to `/posts/:id`? HTML forms can typically only send `POST` and `GET` requests, so Rails puts an `_method` hidden input with the `value` as `patch`. Rails uses this input instead of the method denoted by the form.

This means that the `new` post form and the `edit` post form can be identical, so we can abstract that away with a partial. We just need to make sure we have an instance variable with the same name as `form_for` needs.

### `before_action`

This is a way of running some code before an action:

```ruby
class PostsController < ApplicationController
  before_action :set_post
  # ...
  private
  # ...
  def set_post
    @post = Post.find params[:id]
  end
end
```

`set_post` will be called before each action in the controller. If we want to limit this to a few actions, we can use `:only`:

```ruby
# ...
  before_action :set_post, only: [:show, :edit, :update]
# ...
```

We use this for a few different reasons:

- Setting up instance variables
- Redirecting based on some condition
  - The action no longer executes if we redirect in a `before_action`.
  - This is good for checking logins.
